Index: Source/TetrisGang/TP_WeaponComponent.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright Epic Games, Inc. All Rights Reserved.\r\n\r\n\r\n#include \"TP_WeaponComponent.h\"\r\n#include \"TetrisGangCharacter.h\"\r\n#include \"TetrisGangProjectile.h\"\r\n#include \"GameFramework/PlayerController.h\"\r\n#include \"Camera/PlayerCameraManager.h\"\r\n#include \"Kismet/GameplayStatics.h\"\r\n#include \"EnhancedInputComponent.h\"\r\n#include \"EnhancedInputSubsystems.h\"\r\n\r\n// Sets default values for this component's properties\r\nUTP_WeaponComponent::UTP_WeaponComponent()\r\n{\r\n  // Default offset from the character location for projectiles to spawn\r\n  MuzzleOffset = FVector(100.0f, 0.0f, 10.0f);\r\n  StaticProjectile = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"StaticProjectileComponent\"));\r\n\r\n}\r\n\r\n\r\nvoid UTP_WeaponComponent::Fire()\r\n{\r\n  if (Character == nullptr || Character->GetController() == nullptr)\r\n  {\r\n    return;\r\n  }\r\n\r\n  if (ProjectileClass != nullptr)\r\n  {\r\n    UWorld* const World = GetWorld();\r\n    if (World != nullptr)\r\n    {\r\n      APlayerController* PlayerController = Cast<APlayerController>(Character->GetController());\r\n      const FRotator SpawnRotation = PlayerController->PlayerCameraManager->GetCameraRotation();\r\n      // MuzzleOffset is in camera space, so transform it to world space before offsetting from the character location to find the final muzzle position\r\n      const FVector SpawnLocation = GetOwner()->GetActorLocation() + SpawnRotation.RotateVector(MuzzleOffset);\r\n\r\n      //Set Spawn Collision Handling Override\r\n      FActorSpawnParameters ActorSpawnParams;\r\n      ActorSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding;\r\n\r\n      // Spawn the projectile at the muzzle\r\n      ATetrisGangProjectile* ActualProjectile = World->SpawnActor<ATetrisGangProjectile>(ProjectileClass, SpawnLocation, SpawnRotation, ActorSpawnParams);\r\n      if (IsValid(ActualProjectile))\r\n      {\r\n        ActualProjectile->Rotation = ActualRotation;\r\n        ActualProjectile->Piece = ActualPiece;\r\n        ActualProjectile->Rotate();\r\n        ActualProjectile->UpdateMesh(ActualMesh);\r\n      }\r\n    }\r\n\r\n    // Try and play the sound if specified\r\n    if (FireSound != nullptr)\r\n    {\r\n      UGameplayStatics::PlaySoundAtLocation(this, FireSound, Character->GetActorLocation());\r\n    }\r\n\r\n    // Try and play a firing animation if specified\r\n    if (FireAnimation != nullptr)\r\n    {\r\n      // Get the animation object for the arms mesh\r\n      UAnimInstance* AnimInstance = Character->GetMesh1P()->GetAnimInstance();\r\n      if (AnimInstance != nullptr)\r\n      {\r\n        AnimInstance->Montage_Play(FireAnimation, 1.f);\r\n      }\r\n    }\r\n\r\n    CreateRandomProjectile();\r\n  }\r\n}\r\n\r\n\r\nvoid UTP_WeaponComponent::AttachWeapon(ATetrisGangCharacter* TargetCharacter)\r\n{\r\n  Character = TargetCharacter;\r\n\r\n  // Check that the character is valid, and has no rifle yet\r\n  if (Character == nullptr || Character->GetHasRifle())\r\n  {\r\n    return;\r\n  }\r\n\r\n  // Attach the weapon to the First Person Character\r\n  FAttachmentTransformRules AttachmentRules(EAttachmentRule::SnapToTarget, true);\r\n  AttachToComponent(Character->GetMesh1P(), AttachmentRules, FName(TEXT(\"GripPoint\")));\r\n\r\n  // switch bHasRifle so the animation blueprint can switch to another animation set\r\n  Character->SetHasRifle(true);\r\n\r\n  // Set up action bindings\r\n  if (APlayerController* PlayerController = Cast<APlayerController>(Character->GetController()))\r\n  {\r\n    if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))\r\n    {\r\n      // Set the priority of the mapping to 1, so that it overrides the Jump action with the Fire action when using touch input\r\n      Subsystem->AddMappingContext(FireMappingContext, 1);\r\n    }\r\n\r\n    if (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerController->InputComponent))\r\n    {\r\n      // Fire\r\n      EnhancedInputComponent->BindAction(FireAction, ETriggerEvent::Triggered, this, &UTP_WeaponComponent::Fire);\r\n\r\n      // Rotate Bullet\r\n      EnhancedInputComponent->BindAction(RotateBulletLeftAction, ETriggerEvent::Triggered, this, &UTP_WeaponComponent::RotateBulletLeft);\r\n\r\n      // Rotate Bullet\r\n      EnhancedInputComponent->BindAction(RotateBulletRightAction, ETriggerEvent::Triggered, this, &UTP_WeaponComponent::RotateBulletRight);\r\n\r\n    }\r\n\r\n\r\n  }\r\n\r\n  UStaticMeshComponent* capusleComponent = Cast<UStaticMeshComponent>(GetOwner()->FindComponentByTag<UStaticMeshComponent>(FName(TEXT(\"CapsulePosition\"))));\r\n  StaticProjectile->AttachToComponent(GetOwner()->GetRootComponent(), FAttachmentTransformRules::KeepRelativeTransform);\r\n  StaticProjectile->SetRelativeLocation(capusleComponent->GetRelativeLocation());\r\n  StaticProjectile->SetRelativeScale3D(FVector(0.1f, 0.1f, 0.1f));\r\n\r\n  CreateRandomProjectile();\r\n}\r\n\r\nvoid UTP_WeaponComponent::CreateRandomProjectile()\r\n{\r\n  ActualPiece = Constantes::GetRandomPiece();\r\n  ActualRotation = Rotations::Up;\r\n  StaticProjectile->SetRelativeRotation(FRotator(0.0, 0.0, 0.0));\r\n\r\n  switch (ActualPiece)\r\n  {\r\n  case Pieces::Yelow:\r\n    ActualMesh = AvailablePiecesMeshes[0];\r\n    break;\r\n  case Pieces::Cyan:\r\n    ActualMesh = AvailablePiecesMeshes[1];\r\n    break;\r\n  case Pieces::Green:\r\n    ActualMesh = AvailablePiecesMeshes[2];\r\n    break;\r\n  case Pieces::Red:\r\n    ActualMesh = AvailablePiecesMeshes[3];\r\n    break;\r\n  case Pieces::Orange:\r\n    ActualMesh = AvailablePiecesMeshes[4];\r\n    break;\r\n  case Pieces::Blue:\r\n    ActualMesh = AvailablePiecesMeshes[5];\r\n    break;\r\n  case Pieces::Purple:\r\n    ActualMesh = AvailablePiecesMeshes[6];\r\n    break;\r\n  default:\r\n    break;\r\n  }\r\n  //FString  s = ActualMesh->GetFName();\r\n  //UE_LOG(LogTemplateCharacter, Error, TEXT(\"%s\", ));\r\n  if (!IsValid(ActualMesh) || ActualMesh == nullptr) {\r\n      UE_LOG(LogTemplateCharacter, Warning, TEXT(\"Actual Mesh is null\"));\r\n  } \r\n  StaticProjectile->SetStaticMesh(ActualMesh);\r\n}\r\n\r\nvoid UTP_WeaponComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)\r\n{\r\n  if (Character == nullptr)\r\n  {\r\n    return;\r\n  }\r\n\r\n  if (APlayerController* PlayerController = Cast<APlayerController>(Character->GetController()))\r\n  {\r\n    if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))\r\n    {\r\n      Subsystem->RemoveMappingContext(FireMappingContext);\r\n    }\r\n  }\r\n}\r\n\r\n\r\nvoid UTP_WeaponComponent::RotateBulletLeft()\r\n{\r\n  UE_LOG(LogTemplateCharacter, Error, TEXT(\"Rotacion bullet left\"));\r\n\r\n  switch (ActualRotation) {\r\n  case Rotations::Up:\r\n    ActualRotation = Rotations::Left;\r\n    UE_LOG(LogTemplateCharacter, Error, TEXT(\"Actual Rotacion: left\"));\r\n    break;\r\n  case Rotations::Left:\r\n    ActualRotation = Rotations::Down;\r\n    UE_LOG(LogTemplateCharacter, Error, TEXT(\"Actual Rotacion: Down\"));\r\n    break;\r\n  case Rotations::Down:\r\n    ActualRotation = Rotations::Right;\r\n    UE_LOG(LogTemplateCharacter, Error, TEXT(\"Actual Rotacion: Right\"));\r\n    break;\r\n  case Rotations::Right:\r\n    ActualRotation = Rotations::Up;\r\n    UE_LOG(LogTemplateCharacter, Error, TEXT(\"Actual Rotacion: Up\"));\r\n    break;\r\n  }\r\n}\r\n\r\nvoid UTP_WeaponComponent::RotateBulletRight()\r\n{\r\n  UE_LOG(LogTemplateCharacter, Error, TEXT(\"Rotacion bullet right\"));\r\n\r\n  switch (ActualRotation) {\r\n  case Rotations::Up:\r\n    ActualRotation = Rotations::Right;\r\n    StaticProjectile->SetRelativeRotation(FRotator(0.0, 0.0, 90.0));\r\n    UE_LOG(LogTemplateCharacter, Error, TEXT(\"Actual Rotacion: Right\"));\r\n    break;\r\n  case Rotations::Right:\r\n    ActualRotation = Rotations::Down;\r\n    StaticProjectile->SetRelativeRotation(FRotator(0.0, 0.0, 180.0));\r\n    UE_LOG(LogTemplateCharacter, Error, TEXT(\"Actual Rotacion: Down\"));\r\n    break;\r\n  case Rotations::Down:\r\n    ActualRotation = Rotations::Left;\r\n    StaticProjectile->SetRelativeRotation(FRotator(0.0, 0.0, -90.0));\r\n    UE_LOG(LogTemplateCharacter, Error, TEXT(\"Actual Rotacion: left\"));\r\n    break;\r\n  case Rotations::Left:\r\n    ActualRotation = Rotations::Up;\r\n    StaticProjectile->SetRelativeRotation(FRotator(0.0, 0.0, 0.0));\r\n    UE_LOG(LogTemplateCharacter, Error, TEXT(\"Actual Rotacion: Up\"));\r\n    break;\r\n  }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/TetrisGang/TP_WeaponComponent.cpp b/Source/TetrisGang/TP_WeaponComponent.cpp
--- a/Source/TetrisGang/TP_WeaponComponent.cpp	(revision 5c8c96754b3a15534c95465200d90e8cd64f708a)
+++ b/Source/TetrisGang/TP_WeaponComponent.cpp	(date 1697932808522)
@@ -128,7 +128,8 @@
 {
   ActualPiece = Constantes::GetRandomPiece();
   ActualRotation = Rotations::Up;
-  StaticProjectile->SetRelativeRotation(FRotator(0.0, 0.0, 0.0));
+  StaticProjectile->SetRelativeRotation(FRotator(0.0, 200.0, 90.0));
+  StaticProjectile->SetRelativeScale3D(FVector(2.5f, 2.5f, 2.5f));
 
   switch (ActualPiece)
   {
@@ -187,19 +188,53 @@
 
   switch (ActualRotation) {
   case Rotations::Up:
-    ActualRotation = Rotations::Left;
+    if (ActualPiece == Pieces::Yelow) 
+    {
+        ActualRotation = Rotations::Down;
+        StaticProjectile->SetRelativeRotation(FRotator(0.0, 200.0, 0.0));
+    }
+    else {
+        ActualRotation = Rotations::Left;
+        StaticProjectile->SetRelativeRotation(FRotator(-90.0, 200.0, 90.0));
+    }
     UE_LOG(LogTemplateCharacter, Error, TEXT("Actual Rotacion: left"));
     break;
   case Rotations::Left:
-    ActualRotation = Rotations::Down;
+    if (ActualPiece == Pieces::Yelow) 
+    {
+        ActualRotation = Rotations::Down;
+        StaticProjectile->SetRelativeRotation(FRotator(0.0, 200.0, 0.0));
+    }
+    else 
+    {
+        ActualRotation = Rotations::Down;
+        StaticProjectile->SetRelativeRotation(FRotator(180.0, 200.0, 90.0));
+    }
     UE_LOG(LogTemplateCharacter, Error, TEXT("Actual Rotacion: Down"));
     break;
   case Rotations::Down:
-    ActualRotation = Rotations::Right;
+    if (ActualPiece == Pieces::Yelow) 
+    {
+        ActualRotation = Rotations::Up;
+        StaticProjectile->SetRelativeRotation(FRotator(0.0, 200.0, 90.0));
+    }
+    else 
+    {
+        ActualRotation = Rotations::Right;
+        StaticProjectile->SetRelativeRotation(FRotator(90.0, 200.0, 90.0));
+    }
     UE_LOG(LogTemplateCharacter, Error, TEXT("Actual Rotacion: Right"));
     break;
   case Rotations::Right:
-    ActualRotation = Rotations::Up;
+    if (ActualPiece == Pieces::Yelow) {
+        ActualRotation = Rotations::Up;
+        StaticProjectile->SetRelativeRotation(FRotator(0.0, 200.0, 90.0));
+    }
+    else 
+    {
+        ActualRotation = Rotations::Up;
+        StaticProjectile->SetRelativeRotation(FRotator(0.0, 200.0, 90.0));
+    }
     UE_LOG(LogTemplateCharacter, Error, TEXT("Actual Rotacion: Up"));
     break;
   }
@@ -211,23 +246,55 @@
 
   switch (ActualRotation) {
   case Rotations::Up:
-    ActualRotation = Rotations::Right;
-    StaticProjectile->SetRelativeRotation(FRotator(0.0, 0.0, 90.0));
+    if (ActualPiece == Pieces::Yelow) 
+    {
+        ActualRotation = Rotations::Down;
+        StaticProjectile->SetRelativeRotation(FRotator(0.0, 200.0, 0.0));
+    }
+    else
+    {
+        ActualRotation = Rotations::Right;
+        StaticProjectile->SetRelativeRotation(FRotator(90.0, 200.0, 90.0));
+    }
     UE_LOG(LogTemplateCharacter, Error, TEXT("Actual Rotacion: Right"));
     break;
   case Rotations::Right:
-    ActualRotation = Rotations::Down;
-    StaticProjectile->SetRelativeRotation(FRotator(0.0, 0.0, 180.0));
+    if (ActualPiece == Pieces::Yelow) 
+    {
+        ActualRotation = Rotations::Down;
+        StaticProjectile->SetRelativeRotation(FRotator(0.0, 200.0, 0.0));
+    }
+    else
+    {
+        ActualRotation = Rotations::Down;
+        StaticProjectile->SetRelativeRotation(FRotator(180.0, 200.0, 90.0));
+    }
     UE_LOG(LogTemplateCharacter, Error, TEXT("Actual Rotacion: Down"));
     break;
   case Rotations::Down:
-    ActualRotation = Rotations::Left;
-    StaticProjectile->SetRelativeRotation(FRotator(0.0, 0.0, -90.0));
+    if (ActualPiece == Pieces::Yelow)
+    {
+        ActualRotation = Rotations::Up;
+        StaticProjectile->SetRelativeRotation(FRotator(0.0, 200.0, 90.0));
+    }
+    else
+    {
+        ActualRotation = Rotations::Left;
+        StaticProjectile->SetRelativeRotation(FRotator(-90.0, 200.0, 90.0));
+    }
     UE_LOG(LogTemplateCharacter, Error, TEXT("Actual Rotacion: left"));
     break;
   case Rotations::Left:
-    ActualRotation = Rotations::Up;
-    StaticProjectile->SetRelativeRotation(FRotator(0.0, 0.0, 0.0));
+    if (ActualPiece == Pieces::Yelow) 
+    {
+        ActualRotation = Rotations::Up;
+        StaticProjectile->SetRelativeRotation(FRotator(0.0, 200.0, 90.0));
+    }
+    else
+    {
+        ActualRotation = Rotations::Up;
+        StaticProjectile->SetRelativeRotation(FRotator(0.0, 200.0, 90.0));
+    }
     UE_LOG(LogTemplateCharacter, Error, TEXT("Actual Rotacion: Up"));
     break;
   }
Index: Source/TetrisGang/TetrisGangProjectile.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright Epic Games, Inc. All Rights Reserved.\r\n\r\n#include \"TetrisGangProjectile.h\"\r\n#include \"GameFramework/ProjectileMovementComponent.h\"\r\n#include \"Components/StaticMeshComponent.h\"\r\n#include \"Components/SphereComponent.h\"\r\n#include \"Constantes.h\"\r\n\r\nvoid ATetrisGangProjectile::BeginPlay()\r\n{\r\n\tSuper::BeginPlay();\r\n\r\n\tPieceMesh = Cast<UStaticMeshComponent>(GetComponentByClass(UStaticMeshComponent::StaticClass()));\r\n}\r\n\r\nATetrisGangProjectile::ATetrisGangProjectile()\r\n{\r\n\t// Use a sphere as a simple collision representation\r\n\tCollisionComp = CreateDefaultSubobject<USphereComponent>(TEXT(\"SphereComp\"));\r\n\tCollisionComp->InitSphereRadius(5.0f);\r\n\tCollisionComp->BodyInstance.SetCollisionProfileName(\"Projectile\");\r\n\tCollisionComp->OnComponentHit.AddDynamic(this, &ATetrisGangProjectile::OnHit);\t\t// set up a notification for when this component hits something blocking\r\n\r\n\t// Players can't walk on it\r\n\tCollisionComp->SetWalkableSlopeOverride(FWalkableSlopeOverride(WalkableSlope_Unwalkable, 0.f));\r\n\tCollisionComp->CanCharacterStepUpOn = ECB_No;\r\n\r\n\t// Set as root component\r\n\tRootComponent = CollisionComp;\r\n\r\n\t// Use a ProjectileMovementComponent to govern this projectile's movement\r\n\tProjectileMovement = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT(\"ProjectileComp\"));\r\n\tProjectileMovement->UpdatedComponent = CollisionComp;\r\n\tProjectileMovement->InitialSpeed = 3000.f;\r\n\tProjectileMovement->MaxSpeed = 3000.f;\r\n\tProjectileMovement->bRotationFollowsVelocity = true;\r\n\tProjectileMovement->bShouldBounce = true;\r\n\tProjectileMovement->ProjectileGravityScale = 0.f;\r\n\r\n\t// Die after 3 seconds by default\r\n\tInitialLifeSpan = 3.0f;\r\n}\r\n\r\nvoid ATetrisGangProjectile::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\r\n{\r\n\t// Only add impulse and destroy projectile if we hit a physics\r\n\tif ((OtherActor != nullptr) && (OtherActor != this) && (OtherComp != nullptr) && OtherComp->IsSimulatingPhysics())\r\n\t{\r\n\t\tOtherComp->AddImpulseAtLocation(GetVelocity() * 100.0f, GetActorLocation());\r\n\r\n\t\tDestroy();\r\n\t}\r\n}\r\n\r\nvoid ATetrisGangProjectile::UpdateMesh(UStaticMesh *NewMesh)\r\n{\r\n\tPieceMesh->SetStaticMesh(NewMesh);\r\n}\r\n\r\nvoid ATetrisGangProjectile::Rotate()\r\n{\r\n\tswitch (Rotation)\r\n\t{\r\n\t\tcase Rotations::Up: \r\n\t\t\tPieceMesh->SetRelativeRotation(FRotator(0.0, 0.0, 0.0));\r\n\t\t\tbreak;\r\n\t\tcase Rotations::Right:\r\n\t\t\tPieceMesh->SetRelativeRotation(FRotator(0.0, 0.0, 90.0));\r\n\t\t\tbreak;\r\n\t\tcase Rotations::Down:\r\n\t\t\tPieceMesh->SetRelativeRotation(FRotator(0.0, 0.0, 180.0));\r\n\t\t\tbreak;\r\n\t\tcase Rotations::Left:\r\n\t\t\tPieceMesh->SetRelativeRotation(FRotator(0.0, 0.0, -90.0));\r\n\t\t\tbreak;\r\n\t}\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/TetrisGang/TetrisGangProjectile.cpp b/Source/TetrisGang/TetrisGangProjectile.cpp
--- a/Source/TetrisGang/TetrisGangProjectile.cpp	(revision 5c8c96754b3a15534c95465200d90e8cd64f708a)
+++ b/Source/TetrisGang/TetrisGangProjectile.cpp	(date 1697933284427)
@@ -55,6 +55,7 @@
 void ATetrisGangProjectile::UpdateMesh(UStaticMesh *NewMesh)
 {
 	PieceMesh->SetStaticMesh(NewMesh);
+	PieceMesh->SetRelativeScale3D(FVector(15.0, 15.0, 15.0));
 }
 
 void ATetrisGangProjectile::Rotate()
@@ -62,16 +63,16 @@
 	switch (Rotation)
 	{
 		case Rotations::Up: 
-			PieceMesh->SetRelativeRotation(FRotator(0.0, 0.0, 0.0));
+			PieceMesh->SetRelativeRotation(FRotator(0.0, 90.0, 90.0));
 			break;
 		case Rotations::Right:
-			PieceMesh->SetRelativeRotation(FRotator(0.0, 0.0, 90.0));
+			PieceMesh->SetRelativeRotation(FRotator(90.0, 90.0, 90.0));
 			break;
 		case Rotations::Down:
-			PieceMesh->SetRelativeRotation(FRotator(0.0, 0.0, 180.0));
+			PieceMesh->SetRelativeRotation(FRotator(180.0, 90.0, 90.0));
 			break;
 		case Rotations::Left:
-			PieceMesh->SetRelativeRotation(FRotator(0.0, 0.0, -90.0));
+			PieceMesh->SetRelativeRotation(FRotator(-90.0, 90.0, 90.0));
 			break;
 	}
 }
\ No newline at end of file
